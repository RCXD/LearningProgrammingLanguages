# 1. scalar
# Metaph: 노란색 달걀, 흰색 달걀
# 문자, 숫자, 논리형이냐의 데이터 형태가 존재
a <- 2.7
b <- 'hello'

# 데이터 형태 확인
class(a)
typeof(a)
mode(a)

# 2. Vector
# 같은 자료형을 가진 스칼라값들을 일려로 나열한 구조
# 순서(index)를 가지고 있음.

vec1 <- 1:5
vec1

vec2 <- c(1, 2, 3, 4, 5)

vec3 <- c(TRUE, FALSE, TRUE)

### 심화 ###
vec4 <- c(1.1:10)   #1,1 ~ 9.1까지 만들어짐
vec4 <- c(1.1:10.1) #10.1까지 만들어짐
vec5 <- c(8.5:4.5)  #역순도 가능
vec6 <- seq(1, 10, by=2) #간격설정 가능

#자료형
class(c(1,2,3))           #전부 numeric
class(c(1,'2',3))         #문자 큰 자료형이므로 큰 자료형으로 맞춰짐
class(c(1,'2',3,TRUE))    #마찬가지
class(c(1,'2',3,TRUE)[3]) #TRUE마저도 문자열로 바뀜

#벡터 이름지정(naming)
vec1 <- 1:5
names(vec1) # 초기이름은 NULL
names(vec1) <- c('a', 'b', 'c', 'd', 'e')
names(vec1)

#실습 : vec1에서 값 3을 name으로 조회
vec1['c']

#실습 : vec1에서 값2와 값4를 이름으로 조회
vec1['b']; vec1['d']
#vec1['b', 'd']는 다른 자료구조의 index 형식과 충돌
vec1[c('b','d')]


vec7 <- vec1[c('b', 'd')]
vec7[1]
vec7[2]

#벡터 연산법
#기존 프로그래밍과 다른 연산법을 가짐
#기존 프로그래밍에서는 배열(혹은 리스트)의 모든 자리에
#특정한 연산을 하려면 반복문을 통해서만 가능했다.
#한번에 모든 자리의 연산을 동시에 실행이 가능하다.
vec1 + 5
vec1 * 2
### 질문 ###
#name도 한번에 바꿀 수 있으려나?
#모르겠다

#실습
vec1 %% 2 == 0

#벡터 값 조회
# 논리형 값을 가지고 벡터의 조회
vec1[1]
vec1[2]
### 심화 ###
vec1[c(TRUE, FALSE, FALSE, FALSE, TRUE)] #원하는 장소의 값만 읽기
vec1[vec1 %% 2 == 0] #따라서 이것도 가능한것임.