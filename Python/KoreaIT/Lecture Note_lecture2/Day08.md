# 정렬 
자료구조에서 중요한 알고리즘.  
단, 자료구조라고 하긴 어렵다고.  
데이터를 순서대로 나열하기 위한 절차적인 과정  

- 선택, 삽입, 버블, 퀵 ... 종류는 엄청 많다. 정렬만 되면 되니까.


## 알고리즘의 성능 분석
- 어떤 알고리즘이 좋은지를 판단하기 위한 기준!
  - 정확성: 올바른 자료가 입력되었을 때에 유한한 시간 내에 올바른 결과를 도출하는가?
  - 명확성: 알고리즘이 이해가기 쉽고 명확하게 작성되었나? (확인바람)
    - 이 알고리즘이 항상 같은 작업을 수행할 수 있는가?
      - ex. 선택정렬은 계속 선택으로 정렬해야 하는데, 어느날 다른 동작을 한다면...
  - 수행량: 알고리즘의 주요 연산이 얼마나 반복되는가?
  - 메모리 사용량: 문제를 해결하기 위해 **얼마나 많은 메모리 공간**을 필요로 하는가?
  - 최적성: 알고리즘이 문제의 해결 조건에 **최적으로 부합**하는가?


## 성능 분석방법
1. 공간 복잡도(Space Complexity)
   1. 알고리즘을 프로그램으로 실행하여 완료하는데 필요한 총 저장공간을 의미
2. 시간 복잡도(Time Complexity) [Ref](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84)
   1. 알고리즘을 프로그램으로 실행하여 완료하는데까지 소요되는 시간
      1. 컴퓨터 프로그램의 입력값과 연산 수행시간의 상관관계를 나타낸 척도


## 선택정렬(Selection Sort)
최소값 또는 최대값을 선택하여 가장 앞에다가 위치하는 작업을 반복하여 정렬하는 방법

- 시간복잡도: O(n^2)
- 장점: 구현이 쉽다.(빠른 구현 가능)
- 단점: 다른 정렬에 비해 시간이 오래걸린다

- 기본 로직:(난이도: 쉬운편!)
    1. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후의 값 중에 최소값을 찾아낸다
       1. ex) 4 1 3 5 2
    2. 가장 작은값을 찾아내면 그 값을 현재 인덱스의 값과 바꿔준다
       1. ex) 1 4 3 5 2
    3. 다음 인덱스로 이동하여 위의 과정을 반복한다

## 삽입정렬(Insertion Sort)
현재 위치에서 그 앞에 인덱스들 중에 자신이 들어갈 위치를 찾아서 그 위치에 삽입하여 정렬하는 방법

- 시간복잡도: O(n) ~ O(n^2) - 데이터의 상태에 따라 빨라질 수 있다.
- 장점: 최선의 경우 빠른 효율성을 갖는다.
- 단점: 최악의 경우에는 큰 시간복잡도를 가지며, 데이터의 상태나 크기에 따라 성능의 편차가 크다.
- 기본 로직:
    1. 현재 인덱스(i)를 임시저장한다(tmp)
    2. i부터 시작해서 앞에 위치한 값이 더 작다면 둘을 바꿔주고
    3. 인덱스(i)를 하나 감소시킨다.
    4. i를 1 증가시킨 후 위 과정 반복
       1. 5 1 2 4 3 -> 1 5 2 4 3 -> 1 2 5 4 3 -> 1 2 4 3 5 
       2. 인덱스와 그 다음 인덱스를 비교해서 자리바꾸고 이동, 안끝났으면 다시 반복


## 버블정렬(Bubble Sort)
인접한 두 수를 비교하여 큰 수를 뒤로 보내는 작접을 반복하여 정렬하는 방법

- 시간복잡도: O(n^2) -> 좋은 편은 아닌 듯
- 장점: 구현이 쉽고 코드가 직관적이다.
- 단점: 시간이 오래걸린다.

- Tx. 동작 로직을 한번 작성해보자...


## 퀵 정렬(Quick Sort)
분할정복(Divide and Conquer) 방식으로 정렬을 수행하는 방법
문제를 작은 2개로 분리하고, 각각 해결하여 모아서 원래의 문제를 해결하는 방법(?)
- 시간복잡도: O(nlogN) # 상당히 효율적!
- 장점: 알고리즘 중 가장 빠른 평균시간을 갖는다.
- 단점: 구현이 복잡하다
- 기본로직
  1. 리스트 안에 한 요소를 선택(pivot)
  2. pivot을 기준으로 pivot보다 작은 요소는 왼쪽으로, pivot보다 큰 요소는 오른쪽으로 옮겨짐
  3. pivot을 제외한 왼쪽, 오른쪽 리스트를 정렬, 분할된 리시트들도 순환호출을 이용하여 정렬
  4. 분할된 리스트의 크기가 1이 되어 더이상 분할이 불가능할때까지 반복

## 분할정복
    문제를 작은 2개로 분리하고 각각 해결하여 모아서 원래의 문제를 해결하는 방법

