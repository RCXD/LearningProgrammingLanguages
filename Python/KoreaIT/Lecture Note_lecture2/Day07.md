트리 순회방식(스캔?)

전위순회: root->left->right  
    서브트리 하나씩 해결해나감
중위순회: left->root->right
후위순회: left->right->root 
    루트가 맨 뒤에 있어야 후ㅟ.
    루트가 맨 앞에 있어야 전위.
https://m.blog.naver.com/rlakk11/60159303809

# 해싱
    순전히 검색 알고리즘이다. 다른것들은 검색 말고도 용도가 있다나?
~~~python
arData = []
arData[20] = 20 #데이터의 값과 인덱스 또는 주소를 일치시켜서 직관적으로 찾는 방법.
#단점: 데이터가 너무 크면 빈공간이 매우 커지고, 메모리 누수(낭비)를 일으킨다.
# 20 > 100 > 7 > 90 > 10

#이걸 보완한게 Hashing 알고리즘
~~~

## 해싱알고리즘
메모리 낭비를 최소화하기 위해 저장할 값을 입력받을 시
연산을 통해 새로운 주소값을 생성하고, 메모리에 저장(매핑, mapping)

예) 10의 배수 데이터들을 짝수번 주소에 넣기
    10,20,30,... -> 2,4,6,...


## 구성요소
1. 해시테이블
키들의 해싱을 통해 저장될 공간
key와 value를 연결해주는(mapping해주는) 기준이 되는 것이 해시테이블
2. 해시함수
해싱기법을 사용해서 메모리에 매핑하기 위해 구현된 함수
3. 해싱의 구조
데이터---(연산)--->해시함수---(저장)--->해시테이블
## 해싱 사용 이유
1. 연산을 사용하여 주소값으로 직접 접근하기 위해
2. 정수형 데이터 뿐만 아니라 다른 자료형의 데이터 또한
   저장된 값을 가져올 때 빠르게 가져올 수 있기 때문



## 해시함수의 종류
1. 나눗셈법: 입력값을 크기로 나눈 나머지를 주소로 이용하는 방법
2. 자릿수 접기: 숫자의 각 자릿수를 더해 해시값으로 만드는 방법
    패리티비트?

## 단점(나눗셈법, 자리수접기법)
    매핑이 겹치는 경우의 수가 상대적으로 많다.
    탐색시간도 빠르고 메모리 낭비도 줄어들지만,
    충돌현상과 클러스터 현상이 발생.
    
    충돌: 여러 값들이 동일한 주소에 매핑되는 현상
    클러스터: 매핑되는 주소가 밀접해 있는 현상
        빈 공간이 있어 충분히 활용되지 못하는 현상
        
## 해결책
1. 개방주소법(Open addressing)
   주소 매핑을 깐깐하게 하지 말자는 개념...
   충돌이 나면 다른 주소로 옮김. 버킷?이라고도 한다나.
   - 선형탐색법: 이동폭이 고정폭(상수). 1차 클러스터가 발생할 확률이 높다.
   - 제곱탐색법: 이동폭이 제곱수로 증가. 1차에 몰릴 확률이 매우 낮으나 2차부터 높아진다고 함.(2차클러스터확률 높다)
     - 인덱스 자리에 2차방정식이 들어가는 형태를 모두 제곱탐색법이라 함.
     - 수학적으로 여러 방식이 개발 중
     - 클러스터가 아니라 클러스틴이라나?
   - 중복해싱(이중 해싱): 해시함수를 두 개 사용하는 것

# 한계점
해시는 현재도 개발 중. 현재까지 있는 방법으로도 언젠가는 겹친다.(메모리가 한정되어 있으므로)

2. 체이닝 기법
사슬처럼 연결하는 기법...?
Linked List 개념으로
   각 주소가 기억하는 주소값에 연결리스트를 할당하여
   데이터 삽입 시 충돌이 발생하면 그 리스트에 데이터를 연결하는 방법
    같은 해시값을 갖는 데이터를 계속 추가게 되면
    한 리스트에만 데이터가 추가되므로, 해싱기법을 쓴 것이 무의미해진다!!

# 결론
해싱기법과 체이닝을 적절하게 사용하여 메모리를 관리한다.(실제)




