정렬 (알고리즘)
	데이터를 순서대로 나열(하기 위한 절차적인 과정)

	선택, 삽입, 버블, 퀵, ..

알고리즘의 성능 분석
	
	1. 정확성		: 올바른 자료가 입력되었을 때 유한한 시간 내에
			올바른 결과를 도출하는가?
	2. 명확성		: 알고리즘이 이해가기 쉽고 명확하게 작성되었나?
	3. 수행량		: 알고리즘의 주요 연산이 얼마나 반복되는가?
	4. 메모리 사용량	: 문제를 해결하기 위해 얼마나 많은 메모리 공간을
			필요로 하는가?
	5. 최적성		: 알고리즘이 문제 해결의 조건에 최적으로 부합하는가?

성능 분석방법
	공간 복잡도(Space Complexity)
		알고리즘을 프로그램으로 실행하여 완료하는데 필요한 총 저장공간을 의미

	시간 복잡도(Time Complexity)
		알고리즘을 프로그램으로 실행하여 완료하는데까지 소요되는 시간
		(켬퓨터 프로그램의 입력값과 연산 수행시간의 상관관계를 나타낸 척도)

선택정렬(Selection Sort)

	최소값, 또는 최대값을 선택하여 가장 앞에다가 위치하는 작업을 반복하여
	정렬하는 방법
	시간복잡도 : O(n^2)

	장점 : 구현이 쉽다
	단점 : 다른정렬에 비해 시간이 오래걸린다.

	기본로직
		1. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후의 값 중에
		최소값을 찾아낸다
			4 1 3 5 2
		2. 가장 작은값을 찾으면 그 값을 현재 인덱스의 값과 바꿔준다.
			1 4 3 5 2
		3. 다음 인덱스로 이동하여 위의 과정을 반복한다.

삽입정렬(Insertion Sort)

	현재 위치에서 그 앞에 인덱스들 중에 자신이 들어갈 위치를 찾아서 그 위치에
	삽입하여 정렬하는 방법
	시간복잡도 : O(n)~O(n^2)

	장점 : 최선의 경우 빠른 효율성을 갖는다
	단점 : 최악의 경우에는 큰 시간복잡도를 가지며 데이터의 상태나 크기에 따라
	성능의 편차가 크다

	기본로직
		현재 인덱스(i)를 임시저장한다(tmp)
		tmp 부터 시작해서 앞에 위치한 값이 더 작다면, 둘을 바꿔주고
		인덱스(tmp)를 하나 감소시킨다.
		i를 1 증가시킨 후 위의과정을 반복

버블정렬(Bubble Sort)
	
	인접한 두 수를 비교하여 큰 수를 뒤로 보내는 작업을 반복하여
	정렬하는 방법
	시간복잡도 : O(n^2)

	장점 : 구현이 쉽고 코드가 직관적이다
	단점 : 시간이 오래걸린다

퀵 정렬(Quick Sort)

	분할정복(Divide and Conquer) 방식으로 정렬을 수행하는 방법
	시간복잡도 : O(nlogN)

	장점 : 알고리즘중 가장 빠른 평균시간을 갖는다
	단점 : 구현이 복잡하다

	기본로직
		1. 리스트 안에 한 요소를 선택(pivot)
		2. pivot을 기준으로 pivot보다 작은 요소는 왼쪽으로,
		pivot보다 큰 요소는 오른쪽으로 옮겨짐
		3. pivot을 제외한 왼쪽, 오른쪽 리스트를 정렬
			분할된 리스트들도 순환호출을 이용하여 정렬
		4. 분할된 리스트의 크기가 1이 되어 더이상 분할이 불가능
		할때까지 반복

분할정복
	문제를 작은 2개로 분리하고 각각 해결하여 모아서 원래의 문제를
	해결하는 방법